{"version":3,"sources":["ng://ngx-pinch-zoom/lib/pinch-zoom.component.ts","ng://ngx-pinch-zoom/lib/pinch-zoom.module.ts"],"names":["PinchZoomComponent","elementRef","this","i","scale","initialScale","moveX","moveY","initialMoveX","initialMoveY","lastTap","draggingMode","transitionDuration","doubleTap","doubleTapScale","zoomButton","linearHorizontalSwipe","linearVerticalSwipe","autoZoomOut","disabled","events","EventEmitter","prototype","ngOnInit","element","contentElement","nativeElement","parentElement","elementTarget","querySelector","tagName","setBasicStyles","ondragstart","Object","defineProperty","prefixes","split","window","query","join","matchMedia","matches","imgHeight","getImageHeight","imgWidth","getImageWidth","offsetHeight","offsetWidth","onMouseEnter","event","getElementPosition","isDragging","onMouseMove","preventDefault","eventType","startX","clientX","elementPosition","left","startY","clientY","top","emit","type","centeringImage","transformElement","onMouseUp","updateInitialValues","undefined","onResize","setImageWidth","touchstartHandler","getStartPosition","touchmoveHandler","touches","detectSwipe","handleSwipe","detectLinearSwipe","handleLinearSwipe","length","handlePinch","touchendHandler","doubleTapDetection","toggleZoom","limitZoom","handleLimitZoom","alignImage","moveLeft","index","moveTop","initialDistance","getDistance","moveLeft0","moveLeft1","moveTop0","moveTop1","moveXC","moveYC","distance","getLinearSwipeType","imageWidth","imageHeight","enlargedImageWidth","enlargedImageHeight","moveXRatio","moveYRatio","newImageWidth","newImageHeight","Math","abs","sqrt","pow","pageX","pageY","getElementsByTagName","style","display","height","alignItems","justifyContent","transformOrigin","hostDisplay","hostOverflow","hostHeight","containerHeight","imgElement","maxWidth","maxHeight","duration","transition","transform","Number","_this","currentTime","Date","getTime","tapLength","clearTimeout","doubleTapTimeout","setTimeout","changedTouches","resetScale","img","transitionYRestriction","transitionXRestriction","imgOffsetTop","imgOffsetLeft","getBoundingClientRect","setMoveX","value","setMoveY","Component","args","selector","template","ElementRef","Input","Output","HostBinding","ViewChild","HostListener","PinchZoomModule","NgModule","declarations","imports","CommonModule","exports","entryComponents"],"mappings":"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","sourcesContent":["import {\n    Component,\n    HostBinding,\n    ElementRef,\n    HostListener,\n    OnInit,\n    ViewChild,\n    Input,\n    EventEmitter,\n    Output\n} from '@angular/core';\n\ntype EventType = 'swipe' | 'pinch' | 'horizontal-swipe' | 'vertical-swipe' | 'touchend';\n\n@Component({\n    selector: 'pinch-zoom, [pinch-zoom]',\n    templateUrl: './pinch-zoom.component.html',\n    styleUrls: ['./pinch-zoom.component.css']\n})\n\nexport class PinchZoomComponent implements OnInit {\n\n    i: number = 0;\n    scale: number = 1;\n    initialScale: number = 1;\n    element;\n    elementTarget;\n    elementPosition;\n    parentElement;\n    eventType: EventType;\n    startX: number;\n    startY: number;\n    moveX: number = 0;\n    moveY: number = 0;\n    initialMoveX: number = 0;\n    initialMoveY: number = 0;\n    moveXC: number;\n    moveYC: number;\n    lastTap = 0;\n    draggingMode: boolean = false;\n    distance: number;\n    doubleTapTimeout;\n    initialDistance: number;\n\n    @Input('height') containerHeight: string;\n    @Input('transition-duration') transitionDuration = 200;\n    @Input('double-tap') doubleTap = true;\n    @Input('double-tap-scale') doubleTapScale = 2;\n    @Input('zoom-button') zoomButton = true;\n    @Input('linear-horizontal-swipe') linearHorizontalSwipe = false;\n    @Input('linear-vertical-swipe') linearVerticalSwipe = false;\n    @Input('auto-zoom-out') autoZoomOut = false;\n    @Input('limit-zoom') limitZoom: number;\n    @Input('disabled') disabled: boolean = false;\n\n    @Output() events: EventEmitter<any> = new EventEmitter<any>();\n\n    @HostBinding('style.display') hostDisplay: string;\n    @HostBinding('style.overflow') hostOverflow: string;\n    @HostBinding('style.height') hostHeight: string;\n\n    @ViewChild('content') contentElement: ElementRef;\n\n    constructor(private elementRef: ElementRef) { }\n\n    ngOnInit() {\n        this.element = this.contentElement.nativeElement;\n        this.parentElement = this.elementRef.nativeElement;\n        this.elementTarget = this.element.querySelector('*').tagName;\n\n        this.setBasicStyles();\n\n        this.element.ondragstart = () => false;\n    }\n\n    get isTouchScreen() {\n        var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\n        var mq = function(query) {\n            return window.matchMedia(query).matches;\n        }\n\n        if (('ontouchstart' in window)) {\n            return true;\n        }\n\n        // include the 'heartz' as a way to have a non matching MQ to help terminate the join\n        // https://git.io/vznFH\n        var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\n        return mq(query);\n    }\n\n    get isDragging() {\n        const imgHeight = this.getImageHeight();\n        const imgWidth = this.getImageWidth();\n\n        if (this.scale > 1) {\n            return imgHeight * this.scale > this.parentElement.offsetHeight ||\n                   imgWidth * this.scale > this.parentElement.offsetWidth;\n        }\n        if (this.scale === 1) {\n            return imgHeight > this.parentElement.offsetHeight ||\n                   imgWidth > this.parentElement.offsetWidth;\n        }\n    }\n\n    /*\n     * Desktop listeners\n     */\n\n    @HostListener('mousedown', ['$event'])\n    onMouseEnter(event: MouseEvent): void {\n        this.getElementPosition();\n\n        if (this.isDragging) {\n            this.draggingMode = true;\n        }\n    }\n\n    @HostListener('window:mousemove', ['$event'])\n    onMouseMove(event: MouseEvent): void {\n        if (this.draggingMode) {\n            event.preventDefault();\n\n            if (!this.eventType) {\n                this.startX = event.clientX - this.elementPosition.left;\n                this.startY = event.clientY - this.elementPosition.top;\n            }\n\n            this.eventType = 'swipe';\n            this.events.emit({\n                type: 'swipe',\n                moveX: this.moveX,\n                moveY: this.moveY\n            });\n\n            this.moveX = this.initialMoveX + ((event.clientX - this.elementPosition.left) - this.startX);\n            this.moveY = this.initialMoveY + ((event.clientY - this.elementPosition.top) - this.startY);\n\n            this.centeringImage();\n            this.transformElement(0);\n        }\n    }\n\n    @HostListener('window:mouseup', ['$event'])\n    onMouseUp(event: MouseEvent): void {\n        this.draggingMode = false;\n        this.updateInitialValues();\n        this.eventType = undefined;\n    }\n\n\n    /*\n     * Mobile listeners\n     */\n\n    @HostListener('window:resize', ['$event'])\n    onResize(event: Event): void {\n        this.setImageWidth();\n        this.transformElement(this.transitionDuration);\n    }\n\n    @HostListener('touchstart', ['$event'])\n    touchstartHandler(event): void {\n        if (this.disabled) {\n            return;\n        }\n        \n        this.getElementPosition();\n\n        if (this.eventType === undefined) {\n            this.getStartPosition(event);\n        }\n\n        this.events.emit({ type: 'touchstart' });\n    }\n\n    @HostListener('touchmove', ['$event'])\n    touchmoveHandler(event): void {\n        if (this.disabled) {\n            return;\n        }\n\n        const touches = event.touches;\n\n        // Swipe\n        if (this.detectSwipe(touches) || this.eventType === 'swipe') {\n            this.handleSwipe(event);\n        }\n\n        // Linear swipe\n        if (this.detectLinearSwipe(touches) ||\n            this.eventType === 'horizontal-swipe' ||\n            this.eventType === 'vertical-swipe') {\n\n            this.handleLinearSwipe(event);\n        }\n\n        // Pinch\n        if ((touches.length === 2 && this.eventType === undefined) || \n            this.eventType === 'pinch') {\n\n            this.handlePinch(event);\n        }\n    }\n\n    @HostListener('touchend', ['$event'])\n    touchendHandler(event): void {\n        if (this.disabled) {\n            return;\n        }\n\n        this.i = 0;\n        this.draggingMode = false;\n        const touches = event.touches;\n\n        // Min scale\n        if (this.scale < 1) {\n            this.scale = 1;\n        }\n\n        // Auto Zoom Out\n        if (this.autoZoomOut && this.eventType === 'pinch') {\n            this.scale = 1;\n        }\n\n        // Emit event\n        this.events.emit({ type: 'touchend' });\n\n        // Double Tap\n        if (this.doubleTapDetection() && this.eventType === undefined) {\n            this.toggleZoom(event);\n            this.events.emit({ type: 'double-tap' });\n            return;\n        }\n\n        // Limit Zoom\n        if (this.limitZoom && this.eventType === 'pinch') {\n            this.handleLimitZoom();\n        }\n\n        // Align image\n        if (this.eventType === 'pinch' || this.eventType === 'swipe') {\n            this.alignImage();\n        }\n\n        // Update initial values\n        if (this.eventType === 'pinch' ||\n            this.eventType === 'swipe' ||\n            this.eventType === 'horizontal-swipe' ||\n            this.eventType === 'vertical-swipe') {\n\n            this.updateInitialValues();\n        }\n\n        this.eventType = 'touchend';\n\n        if (touches && touches.length === 0) {\n            this.eventType = undefined;\n        }\n    }\n\n\n    /*\n     * Handlers\n     */\n\n    moveLeft(index: number, touches): number {\n        return touches[index].clientX - this.elementPosition.left;\n    }\n\n    moveTop(index: number, touches): number {\n        return touches[index].clientY - this.elementPosition.top;\n    }\n\n    handleSwipe(event): void {\n        event.preventDefault();\n\n        if (!this.eventType) {\n            this.startX = event.touches[0].clientX - this.elementPosition.left;\n            this.startY = event.touches[0].clientY - this.elementPosition.top;\n        }\n\n        this.eventType = 'swipe';\n        this.events.emit({\n            type: 'swipe',\n            moveX: this.moveX,\n            moveY: this.moveY\n        });\n\n        this.moveX = this.initialMoveX + (this.moveLeft(0, event.touches) - this.startX);\n        this.moveY = this.initialMoveY + (this.moveTop(0, event.touches) - this.startY);\n\n        this.transformElement(0);\n    }\n\n    handlePinch(event): void {\n        event.preventDefault();\n\n        const touches = event.touches;\n\n        if (!this.eventType) {\n            this.initialDistance = this.getDistance(touches);\n\n            const moveLeft0 = this.moveLeft(0, touches);\n            const moveLeft1 = this.moveLeft(1, touches);\n            const moveTop0 = this.moveTop(0, touches);\n            const moveTop1 = this.moveTop(1, touches);\n\n            this.moveXC = ((moveLeft0 + moveLeft1) / 2) - this.initialMoveX;\n            this.moveYC = ((moveTop0 + moveTop1) / 2) - this.initialMoveY;\n        }\n\n        this.eventType = 'pinch';\n        this.distance = this.getDistance(touches);\n        this.scale = this.initialScale * (this.distance / this.initialDistance);\n        this.events.emit({ \n            type: 'pinch', \n            scale: this.scale \n        });\n\n        this.moveX = this.initialMoveX - (((this.distance / this.initialDistance) * this.moveXC) - this.moveXC);\n        this.moveY = this.initialMoveY - (((this.distance / this.initialDistance) * this.moveYC) - this.moveYC);\n\n        this.transformElement(0);\n    }\n\n    handleLinearSwipe(event): void {\n        if (this.linearVerticalSwipe) {\n            event.preventDefault();\n        }\n\n        this.i++;\n\n        if (this.i > 3) {\n            this.eventType = this.getLinearSwipeType(event);\n        }\n\n        if (this.eventType === 'horizontal-swipe') {\n            this.moveX = this.initialMoveX + ((event.touches[0].clientX - this.elementPosition.left) - this.startX);\n            this.moveY = 0;\n        }\n\n        if (this.eventType === 'vertical-swipe') {\n            this.moveX = 0;\n            this.moveY = this.initialMoveY + ((event.touches[0].clientY - this.elementPosition.top) - this.startY);\n        }\n\n        if (this.eventType) {\n            this.events.emit({\n                type: this.eventType,\n                moveX: this.moveX,\n                moveY: this.moveY\n            });\n            this.transformElement(0);\n        }\n    }\n\n    handleLimitZoom(): void {\n        if (this.scale > this.limitZoom){\n            const imageWidth = this.getImageWidth();\n            const imageHeight = this.getImageHeight();\n            const enlargedImageWidth = imageWidth * this.scale;\n            const enlargedImageHeight = imageHeight * this.scale;\n\n            const moveXRatio = this.moveX / (enlargedImageWidth - imageWidth);\n            const moveYRatio = this.moveY / (enlargedImageHeight - imageHeight);\n\n            this.scale = this.limitZoom;\n\n            const newImageWidth = imageWidth * this.scale;\n            const newImageHeight = imageHeight * this.scale;\n\n            this.moveX = -Math.abs((moveXRatio * (newImageWidth - imageWidth)));\n            this.moveY = -Math.abs((-moveYRatio * (newImageHeight - imageHeight)));\n\n            this.centeringImage();\n            this.transformElement(this.transitionDuration);\n        }\n    }\n\n\n    detectSwipe(touches: TouchList): boolean {\n        return touches.length === 1 && this.scale > 1 && !this.eventType;\n    }\n\n    detectLinearSwipe(touches: TouchList): boolean {\n        return touches.length === 1 && this.scale === 1 && !this.eventType;\n    }\n\n    getLinearSwipeType(event): EventType {\n        if (this.eventType !== 'horizontal-swipe' && this.eventType !== 'vertical-swipe') {\n            const movementX = Math.abs(this.moveLeft(0, event.touches) - this.startX);\n            const movementY = Math.abs(this.moveTop(0, event.touches) - this.startY);\n\n            if ((movementY * 3) > movementX) {\n                return this.linearVerticalSwipe ? 'vertical-swipe' : undefined;\n            } else {\n                return this.linearHorizontalSwipe ? 'horizontal-swipe' : undefined;\n            }\n        } else {\n            return this.eventType;\n        }\n    }\n\n    getDistance(touches: TouchList) {\n        return Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2));\n    }\n\n    getImageHeight(): number {\n        return this.element.getElementsByTagName(this.elementTarget)[0].offsetHeight;\n    }\n\n    getImageWidth(): number {\n        return this.element.getElementsByTagName(this.elementTarget)[0].offsetWidth;\n    }\n\n    getStartPosition(event): void {\n        this.startX = event.touches[0].clientX - this.elementPosition.left;\n        this.startY = event.touches[0].clientY - this.elementPosition.top;\n    }\n\n    setBasicStyles(): void {\n        this.element.style.display = 'flex';\n        this.element.style.height = '100%';\n        this.element.style.alignItems = 'center';\n        this.element.style.justifyContent = 'center';\n        this.element.style.transformOrigin = '0 0';\n\n        this.hostDisplay = 'block';\n        this.hostOverflow = 'hidden';\n        this.hostHeight = this.containerHeight;\n\n        this.setImageWidth();\n    }\n\n    setImageWidth(): void {\n        const imgElement = this.element.getElementsByTagName(this.elementTarget);\n\n        if (imgElement.length) {\n            imgElement[0].style.maxWidth = '100%';\n            imgElement[0].style.maxHeight = '100%';\n        }\n    }\n\n    transformElement(duration: number = 50) {\n        this.element.style.transition = `all ${duration}ms`;\n        this.element.style.transform = `\n            matrix(${Number(this.scale)}, 0, 0, ${Number(this.scale)}, ${Number(this.moveX)}, ${Number(this.moveY)})`;\n    }\n\n    doubleTapDetection(): boolean {\n        if (!this.doubleTap) {\n            return false;\n        }\n\n        const currentTime = new Date().getTime();\n        const tapLength = currentTime - this.lastTap;\n\n        clearTimeout(this.doubleTapTimeout);\n\n        if (tapLength < 300 && tapLength > 0) {\n            return true;\n        } else {\n            this.doubleTapTimeout = setTimeout(() => {\n                clearTimeout(this.doubleTapTimeout);\n            }, 300);\n        }\n        this.lastTap = currentTime;\n    }\n\n    public toggleZoom(event: any = false): void {\n        if (this.initialScale === 1) {\n\n            if (event && event.changedTouches) {\n                const changedTouches = event.changedTouches;\n\n                this.scale = this.initialScale * this.doubleTapScale;\n                this.moveX = this.initialMoveX - (changedTouches[0].clientX * (this.doubleTapScale - 1) - this.elementPosition.left);\n                this.moveY = this.initialMoveY - (changedTouches[0].clientY * (this.doubleTapScale - 1) - this.elementPosition.top);\n            } else {\n                this.scale = this.initialScale * 2;\n                this.moveX = this.initialMoveX - this.element.offsetWidth / 2;\n                this.moveY = this.initialMoveY - this.element.offsetHeight / 2;\n            }\n\n            this.centeringImage();\n            this.updateInitialValues();\n            this.transformElement(this.transitionDuration);\n            this.events.emit({ type: 'zoom-in' });\n        } else {\n            this.resetScale();\n            this.events.emit({ type: 'zoom-out' });\n        }\n    }\n\n    resetScale(): void {\n        this.scale = 1;\n        this.moveX = 0;\n        this.moveY = 0;\n        this.updateInitialValues();\n        this.transformElement(this.transitionDuration);\n    }\n\n    updateInitialValues(): void {\n        this.initialScale = this.scale;\n        this.initialMoveX = this.moveX;\n        this.initialMoveY = this.moveY;\n    }\n\n    centeringImage(): boolean {\n        const img = this.element.getElementsByTagName(this.elementTarget)[0];\n        const initialMoveX = this.moveX;\n        const initialMoveY = this.moveY;\n\n        if (this.moveY > 0) {\n            this.moveY = 0;\n        }\n        if (this.moveX > 0) {\n            this.moveX = 0;\n        }\n\n        if (img) {\n            this.transitionYRestriction();\n            this.transitionXRestriction();\n        }\n        if (img && this.scale < 1) {\n            if (this.moveX < this.element.offsetWidth * (1 - this.scale)) {\n                this.moveX = this.element.offsetWidth * (1 - this.scale);\n            }\n        }\n\n        return initialMoveX !== this.moveX || initialMoveY !== this.moveY;\n    }\n\n    public alignImage(): void {\n        const isMoveChanged = this.centeringImage();\n\n        if (isMoveChanged) {\n            this.updateInitialValues();\n            this.transformElement(this.transitionDuration);\n        }\n    }\n\n    transitionYRestriction(): void {\n        const imgHeight = this.getImageHeight();\n\n        if (imgHeight * this.scale < this.parentElement.offsetHeight) {\n            this.moveY = (this.parentElement.offsetHeight - this.element.offsetHeight * this.scale) / 2;\n        } else {\n            const imgOffsetTop = ((imgHeight - this.element.offsetHeight) * this.scale) / 2;\n\n            if (this.moveY > imgOffsetTop) {\n                this.moveY = imgOffsetTop;\n            } else if ((imgHeight * this.scale + Math.abs(imgOffsetTop) - this.parentElement.offsetHeight) + this.moveY < 0) {\n                this.moveY = - (imgHeight * this.scale + Math.abs(imgOffsetTop) - this.parentElement.offsetHeight);\n            }\n        }\n    }\n\n    transitionXRestriction(): void {\n        const imgWidth = this.getImageWidth();\n\n        if (imgWidth * this.scale < this.parentElement.offsetWidth) {\n            this.moveX = (this.parentElement.offsetWidth - this.element.offsetWidth * this.scale) / 2;\n        } else {\n            const imgOffsetLeft = ((imgWidth - this.element.offsetWidth) * this.scale) / 2;\n\n            if (this.moveX > imgOffsetLeft) {\n                this.moveX = imgOffsetLeft;\n            } else if ((imgWidth * this.scale + Math.abs(imgOffsetLeft) - this.parentElement.offsetWidth) + this.moveX < 0) {\n                this.moveX = - (imgWidth * this.scale + Math.abs(imgOffsetLeft) - this.parentElement.offsetWidth);\n            }\n        }\n    }\n\n    getElementPosition(): void {\n        this.elementPosition = this.elementRef.nativeElement.getBoundingClientRect();\n    }\n\n    public setMoveX(value: number, transitionDuration: number = 200): void {\n        this.moveX = value;\n        this.transformElement(transitionDuration);\n    }\n\n    public setMoveY(value: number, transitionDuration: number = 200): void {\n        this.moveY = value;\n        this.transformElement(transitionDuration);\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { PinchZoomComponent } from './pinch-zoom.component'; \n\n@NgModule({\n    declarations: [\n        PinchZoomComponent\n    ],\n    imports: [\n        CommonModule\n    ],\n    exports: [\n        PinchZoomComponent\n    ],\n    entryComponents: [\n        PinchZoomComponent\n    ]\n})\nexport class PinchZoomModule { }\n"]}