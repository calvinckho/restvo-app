import { __extends } from "tslib";
import { WebPlugin, FilesystemDirectory, } from "@capacitor/core";
var FilesystemPluginElectron = /** @class */ (function (_super) {
    __extends(FilesystemPluginElectron, _super);
    function FilesystemPluginElectron() {
        var _this = _super.call(this, {
            name: 'Filesystem',
            platforms: ['electron']
        }) || this;
        _this.NodeFS = null;
        _this.fileLocations = null;
        _this.Path = null;
        _this.fileLocations = { DRIVE_ROOT: '', DOCUMENTS: '' };
        var path = require("path");
        var os = require("os");
        if (os.platform == "win32") {
            _this.fileLocations["DRIVE_ROOT"] = process.cwd().split(path.sep)[0];
        }
        else {
            _this.fileLocations["DRIVE_ROOT"] = '/';
        }
        _this.fileLocations[FilesystemDirectory.Documents] = path.join(os.homedir(), "Documents") + path.sep;
        _this.NodeFS = require('fs');
        _this.Path = path;
        return _this;
    }
    FilesystemPluginElectron.prototype.readFile = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            _this.NodeFS.readFile(lookupPath, options.encoding || 'binary', function (err, data) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({ data: options.encoding ? data : Buffer.from(data, 'binary').toString('base64') });
            });
        });
    };
    FilesystemPluginElectron.prototype.writeFile = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            var data = options.data;
            if (!options.encoding) {
                var base64Data = options.data.indexOf(',') >= 0 ? options.data.split(',')[1] : options.data;
                data = Buffer.from(base64Data, 'base64');
            }
            _this.NodeFS.writeFile(lookupPath, data, options.encoding || 'binary', function (err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    };
    FilesystemPluginElectron.prototype.appendFile = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            _this.NodeFS.appendFile(lookupPath, options.encoding, options.data, function (err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    };
    FilesystemPluginElectron.prototype.deleteFile = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " directory is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            _this.NodeFS.unlink(lookupPath, function (err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    };
    FilesystemPluginElectron.prototype.mkdir = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            if (options.createIntermediateDirectories !== undefined) {
                console.warn('createIntermediateDirectories is deprecated, use recursive');
            }
            var doRecursive = options.createIntermediateDirectories || options.recursive;
            _this.NodeFS.mkdir(lookupPath, { recursive: doRecursive }, function (err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    };
    FilesystemPluginElectron.prototype.rmdir = function (options) {
        var _this = this;
        var path = options.path, directory = options.directory, recursive = options.recursive;
        if (Object.keys(this.fileLocations).indexOf(directory) === -1)
            return Promise.reject(directory + " is currently not supported in the Electron implementation.");
        return this.stat({ path: path, directory: directory })
            .then(function (stat) {
            if (stat.type === 'directory') {
                return _this.readdir({ path: path, directory: directory })
                    .then(function (readDirResult) {
                    if (readDirResult.files.length !== 0 && !recursive) {
                        return Promise.reject(path + " is not empty.");
                    }
                    if (!readDirResult.files.length) {
                        return new Promise(function (resolve, reject) {
                            var lookupPath = _this.fileLocations[directory] + path;
                            _this.NodeFS.rmdir(lookupPath, function (err) {
                                if (err) {
                                    reject(err);
                                    return;
                                }
                                resolve();
                            });
                        });
                    }
                    else {
                        return Promise.all(readDirResult.files.map(function (f) {
                            return _this.rmdir({ path: _this.Path.join(path, f), directory: directory, recursive: recursive });
                        }))
                            .then(function () {
                            return _this.rmdir({ path: path, directory: directory, recursive: recursive });
                        });
                    }
                });
            }
            else {
                return _this.deleteFile({ path: path, directory: directory });
            }
        });
    };
    FilesystemPluginElectron.prototype.readdir = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            _this.NodeFS.readdir(lookupPath, function (err, files) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({ files: files });
            });
        });
    };
    FilesystemPluginElectron.prototype.getUri = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " directory is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            resolve({ uri: lookupPath });
        });
    };
    ;
    FilesystemPluginElectron.prototype.stat = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1)
                reject(options.directory + " is currently not supported in the Electron implementation.");
            var lookupPath = _this.fileLocations[options.directory] + options.path;
            _this.NodeFS.stat(lookupPath, function (err, stats) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({
                    type: (stats.isDirectory() ? 'directory' : (stats.isFile() ? 'file' : 'Not available')),
                    size: stats.size,
                    ctime: stats.ctimeMs,
                    mtime: stats.mtimeMs,
                    uri: lookupPath
                });
            });
        });
    };
    FilesystemPluginElectron.prototype._copy = function (options, doRename) {
        var _this = this;
        if (doRename === void 0) { doRename = false; }
        var copyRecursively = function (src, dst) {
            return new Promise(function (resolve, reject) {
                _this.NodeFS.stat(src, function (err, stats) {
                    if (err) {
                        reject(err);
                        return;
                    }
                    if (stats.isDirectory()) {
                        _this.NodeFS.mkdir(dst, function (err) {
                            if (err) {
                                reject(err);
                                return;
                            }
                            var files = _this.NodeFS.readdirSync(src);
                            Promise.all(files.map(function (file) {
                                return copyRecursively(src + _this.Path.sep + file, dst + _this.Path.sep + file);
                            }))
                                .then(function () { return resolve(); })
                                .catch(reject);
                            return;
                        });
                        return;
                    }
                    var dstParent = _this.Path.dirname(dst).split(_this.Path.sep).pop();
                    _this.NodeFS.stat(dstParent, function (err) {
                        if (err) {
                            _this.NodeFS.mkdirSync(dstParent);
                        }
                        _this.NodeFS.copyFile(src, dst, function (err) {
                            if (err) {
                                reject(err);
                                return;
                            }
                            resolve();
                        });
                    });
                });
            });
        };
        return new Promise(function (resolve, reject) {
            if (!options.from || !options.to) {
                reject('Both to and from must be supplied');
                return;
            }
            if (!options.toDirectory) {
                options.toDirectory = options.directory;
            }
            if (Object.keys(_this.fileLocations).indexOf(options.directory) === -1) {
                reject(options.directory + " is currently not supported in the Electron implementation.");
                return;
            }
            if (Object.keys(_this.fileLocations).indexOf(options.toDirectory) === -1) {
                reject(options.toDirectory + " is currently not supported in the Electron implementation.");
                return;
            }
            var fromPath = _this.fileLocations[options.directory] + options.from;
            var toPath = _this.fileLocations[options.toDirectory] + options.to;
            if (doRename) {
                _this.NodeFS.rename(fromPath, toPath, function (err) {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve();
                });
            }
            else {
                copyRecursively(fromPath, toPath)
                    .then(function () { return resolve(); })
                    .catch(reject);
            }
        });
    };
    FilesystemPluginElectron.prototype.copy = function (options) {
        return this._copy(options, false);
    };
    FilesystemPluginElectron.prototype.rename = function (options) {
        return this._copy(options, true);
    };
    return FilesystemPluginElectron;
}(WebPlugin));
export { FilesystemPluginElectron };
var Filesystem = new FilesystemPluginElectron();
export { Filesystem };
//# sourceMappingURL=filesystem.js.map