{"version":3,"sources":["ng://ngx-autosize/lib/autosize.directive.ts","ng://ngx-autosize/lib/autosize.module.ts"],"names":["AutosizeDirective","element","_zone","this","onlyGrow","useImportant","retries","_destroyed","nativeElement","tagName","_findNestedTextArea","textAreaEl","style","overflow","_onTextAreaFound","Object","defineProperty","prototype","value","_minRows","rows","onInput","textArea","adjust","ngOnDestroy","_windowResizeHandler","window","removeEventListener","ngAfterContentChecked","ngOnChanges","changes","_this","querySelector","shadowRoot","console","warn","setTimeout","_addWindowResizeHandler","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","clearTimeout","Debounce","run","runOutsideAngular","addEventListener","inputsChanged","currentText","_oldContent","offsetWidth","_oldWidth","clone","cloneNode","parent_1","parentNode","width","visibility","position","textContent","appendChild","height","scrollHeight","computedStyle","getComputedStyle","parseInt","getPropertyValue","oldHeight","offsetHeight","willGrow","lineHeight","_getLineHeight","rowsCount","maxRows","maxHeight","Math","max","heightStyle","removeChild","isNaN","styles","fontSize","floor","replace","Directive","selector","ElementRef","NgZone","Input","HostListener","AutosizeModule","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["import {\n    ElementRef,\n    HostListener,\n    Directive,\n    Input,\n    NgZone, OnDestroy, OnChanges, AfterContentChecked\n} from '@angular/core';\n\nconst MAX_LOOKUP_RETRIES = 3;\n\n@Directive({\n    selector: '[autosize]'\n})\n\nexport class AutosizeDirective implements OnDestroy, OnChanges, AfterContentChecked {\n    @Input()\n    set minRows(value) {\n        this._minRows = value;\n        if (this.textAreaEl) {\n            this.textAreaEl.rows = value;\n        }\n    };\n    private _minRows: number;\n\n    @Input() maxRows: number;\n    @Input() onlyGrow = false;\n    @Input() useImportant = false;\n\n    private retries = 0;\n    private textAreaEl: any;\n\n    private _oldContent: string;\n    private _oldWidth: number;\n\n    private _windowResizeHandler;\n    private _destroyed = false;\n\n    @HostListener('input', ['$event.target'])\n    onInput(textArea: HTMLTextAreaElement): void {\n        this.adjust();\n    }\n\n    constructor(\n        public element: ElementRef,\n        private _zone: NgZone\n    ) {\n        if (this.element.nativeElement.tagName !== 'TEXTAREA') {\n            this._findNestedTextArea();\n\n        } else {\n            this.textAreaEl = this.element.nativeElement;\n            this.textAreaEl.style.overflow = 'hidden';\n            this._onTextAreaFound();\n        }\n    }\n\n    ngOnDestroy() {\n        this._destroyed = true;\n        if (this._windowResizeHandler) {\n            window.removeEventListener('resize', this._windowResizeHandler, false);\n        }\n    }\n\n    ngAfterContentChecked() {\n        this.adjust();\n    }\n\n    ngOnChanges(changes) {\n        this.adjust(true);\n    }\n\n    _findNestedTextArea() {\n        this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');\n\n        if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {\n            this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');\n        }\n\n        if (!this.textAreaEl) {\n            if (this.retries >= MAX_LOOKUP_RETRIES) {\n                console.warn('ngx-autosize: textarea not found');\n\n            } else {\n                this.retries++;\n                setTimeout(() => {\n                    this._findNestedTextArea();\n                }, 100);\n            }\n            return;\n        }\n\n        this.textAreaEl.style.overflow = 'hidden';\n        this._onTextAreaFound();\n\n    }\n\n    _onTextAreaFound() {\n        this._addWindowResizeHandler();\n        setTimeout(() => {\n            this.adjust();\n        });\n    }\n\n    _addWindowResizeHandler() {\n        this._windowResizeHandler = Debounce(() => {\n            this._zone.run(() => {\n                this.adjust();\n            });\n        }, 200);\n\n        this._zone.runOutsideAngular(() => {\n            window.addEventListener('resize', this._windowResizeHandler, false);\n        });\n    }\n\n    adjust(inputsChanged = false): void {\n        if (!this._destroyed && this.textAreaEl) {\n\n            const currentText = this.textAreaEl.value;\n\n            if (\n                inputsChanged === false &&\n                currentText === this._oldContent &&\n                this.textAreaEl.offsetWidth === this._oldWidth\n            ) {\n                return;\n            }\n\n            this._oldContent = currentText;\n            this._oldWidth = this.textAreaEl.offsetWidth;\n\n            const clone = this.textAreaEl.cloneNode(true);\n            const parent = this.textAreaEl.parentNode;\n            clone.style.width = this.textAreaEl.offsetWidth + 'px';\n            clone.style.visibility = 'hidden';\n            clone.style.position = 'absolute';\n            clone.textContent = currentText;\n\n            parent.appendChild(clone);\n\n            clone.style.overflow = 'auto';\n            clone.style.height = 'auto';\n\n            let height = clone.scrollHeight;\n\n            // add into height top and bottom borders' width\n            let computedStyle = window.getComputedStyle(clone, null);\n            height += parseInt(computedStyle.getPropertyValue('border-top-width'));\n            height += parseInt(computedStyle.getPropertyValue('border-bottom-width'));\n\n            const oldHeight = this.textAreaEl.offsetHeight;\n            const willGrow = height > oldHeight;\n\n            if (this.onlyGrow === false || willGrow) {\n                const lineHeight = this._getLineHeight();\n                const rowsCount = height / lineHeight;\n\n                if (this._minRows && this._minRows >= rowsCount) {\n                    height = this._minRows * lineHeight;\n\n                } else if (this.maxRows && this.maxRows <= rowsCount) {\n                    // never shrink the textarea if onlyGrow is true\n                    const maxHeight = this.maxRows * lineHeight;\n                    height = this.onlyGrow ? Math.max(maxHeight, oldHeight): maxHeight;\n                    this.textAreaEl.style.overflow = 'auto';\n\n                } else {\n                    this.textAreaEl.style.overflow = 'hidden';\n                }\n\n                let heightStyle = height + 'px';\n                heightStyle += this.useImportant ? ' !important' : '';\n\n                this.textAreaEl.style.height = heightStyle;\n            }\n\n            parent.removeChild(clone);\n        }\n    }\n\n    private _getLineHeight() {\n        let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);\n        if (isNaN(lineHeight) && window.getComputedStyle) {\n            const styles = window.getComputedStyle(this.textAreaEl);\n            lineHeight = parseInt(styles.lineHeight, 10);\n        }\n\n        if (isNaN(lineHeight)) {\n            const fontSize = window.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');\n            lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);\n        }\n\n        return lineHeight;\n    }\n}\n\nfunction Debounce(func, wait, immediate = false) {\n    let timeout;\n    return function () {\n        const context = this;\n        const args = arguments;\n        const later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n","import { NgModule } from '@angular/core';\nimport { AutosizeDirective } from './autosize.directive';\n\n@NgModule({\n  declarations: [AutosizeDirective],\n  imports: [\n  ],\n  exports: [AutosizeDirective]\n})\nexport class AutosizeModule { }\n"]}